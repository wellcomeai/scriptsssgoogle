/******************************************************
 * main.gs (с улучшенной последовательной обработкой API + парсинг данных клиента)
 ******************************************************/

/**
 * Парсит данные клиента из строки формата:
 * "from_user_id:418838097 message_id:49 Валерий Шишкин (@well_sh) ru"
 * @param {string} rawData - сырые данные из столбца
 * @return {Object} объект с chatID и username
 */
function parseUserData(rawData) {
  if (!rawData) {
    return { chatID: null, username: null };
  }
  
  var dataStr = rawData.toString().trim();
  var userId = dataStr.match(/from_user_id:(\d+)/);
  var username = dataStr.match(/@(\w+)/);
  
  return {
    chatID: userId ? userId[1] : null,
    username: username ? username[1] : null
  };
}

/**
 * Формирует итоговый chatID с никнеймом в формате "418838097 (@well_sh)"
 * @param {string} chatID - ID пользователя
 * @param {string} username - никнейм пользователя (без @)
 * @return {string} форматированный chatID
 */
function formatChatIDWithUsername(chatID, username) {
  if (!chatID) return null;
  if (username) {
    return chatID + " (@" + username + ")";
  }
  return chatID;
}

/**
 * Обновляет историю диалогов из "Лист1" и распределяет данные по датам в листе "Диалоги".
 */
function updateDialogHistory() {
  var startTime = new Date();
  writeLog("Начато обновление диалогов");

  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sourceSheet = ss.getSheetByName("Лист1");
  if (!sourceSheet) {
    writeLog("Лист1 не найден!", "ERROR");
    return;
  }

  var data = sourceSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeLog("Нет данных для обработки в Лист1.", "WARNING");
    return;
  }

  var headers = data[0];
  var chatIDIndex = headers.indexOf("Уникальный номер канала общения");
  var userDataIndex = headers.indexOf("Уникальный номер клиента");
  var clientMsgIndex = headers.indexOf("Фраза клиента");
  var botMsgIndex = headers.indexOf("Фраза бота");
  var timestampIndex = headers.indexOf("Дата и время");
  // Колонка P (индекс 15) – отметка "Обработано"
  var processedIndex = 15;

  if (chatIDIndex === -1 || clientMsgIndex === -1 || botMsgIndex === -1 || timestampIndex === -1) {
    writeLog("Не найдены необходимые колонки в Лист1.", "ERROR");
    return;
  }
  
  if (userDataIndex === -1) {
    writeLog("Не найден столбец 'Уникальный номер клиента'. Будет использоваться только 'Уникальный номер канала общения'.", "WARNING");
  }

  // Сессии, сгруппированные по chatID (с никнеймом)
  var sessions = {};
  for (var i = 1; i < data.length; i++) {
    var row = data[i];
    var rawChatID = row[chatIDIndex];
    
    // Пытаемся получить chatID и никнейм из столбца "Уникальный номер клиента"
    var finalChatID = null;
    if (userDataIndex !== -1 && row[userDataIndex]) {
      var userData = parseUserData(row[userDataIndex]);
      if (userData.chatID) {
        finalChatID = formatChatIDWithUsername(userData.chatID, userData.username);
        writeLog("Распарсены данные: chatID=" + userData.chatID + ", username=" + userData.username, "DEBUG");
      }
    }
    
    // Если не удалось получить из нового столбца, используем старый chatID
    if (!finalChatID && rawChatID) {
      finalChatID = cleanChatID(rawChatID);
    }
    
    if (!finalChatID) continue;

    // Пропускаем строки, где уже стоит отметка в колонке P
    var processed = row[processedIndex];
    if (processed && processed.toString().trim() !== "") continue;

    // Дата (в формате dd.MM.yyyy)
    var ts = new Date(row[timestampIndex]);
    var dateStr = Utilities.formatDate(ts, ss.getSpreadsheetTimeZone(), "dd.MM.yyyy");

    if (!sessions[finalChatID]) {
      sessions[finalChatID] = { dates: {}, rows: [] };
    }
    if (!sessions[finalChatID].dates[dateStr]) {
      sessions[finalChatID].dates[dateStr] = [];
    }

    sessions[finalChatID].dates[dateStr].push({
      timestamp: row[timestampIndex],
      client: row[clientMsgIndex] || "",
      bot: row[botMsgIndex] || ""
    });

    // Запоминаем номер строки для отметки
    sessions[finalChatID].rows.push(i + 1);
  }

  var sessionsProcessed = 0;
  for (var finalChatID in sessions) {
    var session = sessions[finalChatID];
    var newData = {};

    for (var dateStr in session.dates) {
      var messages = session.dates[dateStr];
      messages.sort(function(a, b) {
        return new Date(a.timestamp) - new Date(b.timestamp);
      });
      var dialog = "";
      for (var j = 0; j < messages.length; j++) {
        dialog += "[" + messages[j].timestamp + "] Клиент: " + messages[j].client + "\nАссистент: " + messages[j].bot + "\n\n";
      }
      newData[dateStr] = dialog.trim();
    }
    updateDialogSheetForChatID(finalChatID, newData);

    // Помечаем строки как "Обработано"
    for (var r = 0; r < session.rows.length; r++) {
      sourceSheet.getRange(session.rows[r], processedIndex + 1).setValue("Обработано");
    }
    sessionsProcessed++;
  }

  // Обновляем дату последнего обновления
  var dialogSheet = getDialogSheet();
  var now = new Date();
  dialogSheet.getRange("D1").setValue(
    "Последнее обновление: " + Utilities.formatDate(now, ss.getSpreadsheetTimeZone(), "dd.MM.yyyy HH:mm")
  );

  formatDialogSheet();
  var endTime = new Date();
  var duration = (endTime - startTime) / 1000;
  writeLog("Обновление диалогов завершено. Сессий: " + sessionsProcessed + ". Время: " + duration + " сек.");

  // Если API активен — запускаем обработку
  if (isApiRunning()) {
    writeLog("API активен, запускаем processApiMessagesSequential...");
    processApiMessagesSequential(true);
  }
}

/**
 * Обновляет/добавляет данные для chatID в листе "Диалоги".
 * Добавляет маркер "[Собран ...]" в начало если его нет.
 * ПРАВИЛЬНО ДОБАВЛЯЕТ новые данные к существующим для одного chatID.
 * Теперь работает с chatID в формате "418838097 (@well_sh)"
 */
function updateDialogSheetForChatID(finalChatID, newData) {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = getDialogSheet();

  if (dialogSheet.getLastRow() < 1) {
    dialogSheet.getRange("A1").setValue("ChatID");
  }

  var dates = Object.keys(newData);
  dates.sort();

  var lastRow = dialogSheet.getLastRow();
  var chatIDValues = [];
  if (lastRow >= 2) {
    chatIDValues = dialogSheet.getRange(2, 1, lastRow - 1, 1).getValues();
  }

  // Ищем строку с нужным chatID
  var rowIndex = 0;
  for (var i = 0; i < chatIDValues.length; i++) {
    if (chatIDValues[i][0] == finalChatID) {
      rowIndex = i + 2;
      break;
    }
  }

  // Если chatID не найден, создаем новую строку
  if (rowIndex === 0) {
    rowIndex = dialogSheet.getLastRow() + 1;
    dialogSheet.getRange(rowIndex, 1).setValue(finalChatID);
    writeLog("Создана новая строка для ChatID: " + finalChatID, "INFO");
  } else {
    writeLog("Найдена существующая строка для ChatID: " + finalChatID + " (строка " + rowIndex + ")", "INFO");
  }

  var now = new Date();
  var collectTimeStr = Utilities.formatDate(now, ss.getSpreadsheetTimeZone(), "dd.MM.yyyy HH:mm:ss");
  var collectMarker = "[Собран " + collectTimeStr + "]\n\n";

  // Обрабатываем каждую дату из новых данных
  for (var i = 0; i < dates.length; i++) {
    var dateStr = dates[i];
    var colIndex = i + 2; 
    var cell = dialogSheet.getRange(rowIndex, colIndex);
    var currentContent = cell.getValue();
    
    // Проверяем, есть ли уже содержимое в ячейке
    if (currentContent && currentContent.toString().trim() !== "") {
      writeLog("Добавляем данные к существующей ячейке для ChatID " + finalChatID + ", дата " + dateStr, "INFO");
      
      // Проверяем, есть ли в текущем контенте маркер "[Обработано ИИ]"
      var isProcessed = currentContent.toString().indexOf("[Обработано ИИ]") !== -1;
      
      if (isProcessed) {
        // Если ячейка уже обработана ИИ, добавляем новые данные после обработанного контента
        writeLog("Ячейка уже обработана ИИ, добавляем после существующего контента", "INFO");
        
        // Ищем, где заканчивается обработанный ИИ контент
        var processedContent = currentContent.toString();
        var lastContainerData = processedContent + "\n\n" + collectMarker + newData[dateStr];
        cell.setValue(lastContainerData);
      } else {
        // Ячейка не обработана ИИ, просто добавляем новые данные
        
        // Проверяем, есть ли маркер [Собран]
        if (currentContent.toString().indexOf("[Собран ") === -1) {
          // Если нет маркера, добавляем его
          cell.setValue(collectMarker + currentContent + "\n\n" + newData[dateStr]);
        } else {
          // Маркер уже есть, добавляем только новые данные
          cell.setValue(currentContent + "\n\n" + newData[dateStr]);
        }
      }
    } else {
      // Ячейка была пустой, добавляем новые данные с маркером
      writeLog("Создаем новую ячейку для ChatID " + finalChatID + ", дата " + dateStr, "INFO");
      cell.setValue(collectMarker + newData[dateStr]);
    }
  }
}

/**
 * Возвращает или создаёт лист "Диалоги".
 */
function getDialogSheet() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) {
    dialogSheet = ss.insertSheet("Диалоги");
    dialogSheet.getRange("A1").setValue("ChatID");
    dialogSheet.getRange("B1").setValue("ID бота");
    dialogSheet.getRange("C1").setValue("API токен");
    dialogSheet.getRange("D1").setValue("Последнее обновление: ");
    dialogSheet.getRange("E1").setValue("API обработчик: Остановлен");
    dialogSheet.getRange("E1").setBackground("#ffe6e6").setFontWeight("bold");

    PropertiesService.getScriptProperties().setProperty('API_RUNNING', 'false');
    writeLog("Создан новый лист 'Диалоги'");
  }
  return dialogSheet;
}

/**
 * Очищает chatID, оставляя число между "tb" и "_".
 */
function cleanChatID(rawChatID) {
  var cleaned = rawChatID;
  if (typeof cleaned === "string" && cleaned.indexOf("tb") === 0) {
    var underscoreIndex = cleaned.indexOf("_");
    if (underscoreIndex !== -1) {
      cleaned = cleaned.substring(2, underscoreIndex);
    }
  }
  return cleaned;
}

/**
 * Применяет форматирование к листу "Диалоги".
 */
function formatDialogSheet() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getSheetByName("Диалоги");
  if (!sheet) return;

  var dataRange = sheet.getDataRange();
  dataRange.setWrap(true);
  dataRange.setBorder(true, true, true, true, true, true);

  var numCols = dataRange.getNumColumns();
  var numRows = dataRange.getNumRows();
  var allRange = sheet.getRange(1, 1, numRows, numCols);
  allRange.setHorizontalAlignment("center");

  var chatIDRange = sheet.getRange(1, 1, numRows, 1);
  chatIDRange.setHorizontalAlignment("left");
  chatIDRange.setFontWeight("bold");
  chatIDRange.setBackground("#f0f0f0");

  if (numRows >= 1 && numCols >= 5) {
    var headerRow = sheet.getRange(1, 1, 1, 5);
    headerRow.setFontWeight("bold").setBackground("#e6f2ff");
  }

  sheet.setColumnWidth(1, 150);
  sheet.setColumnWidth(2, 200);
  sheet.setColumnWidth(3, 300);
  sheet.setColumnWidth(4, 250);
  sheet.setColumnWidth(5, 200);

  for (var i = 7; i <= numCols; i++) {
    sheet.autoResizeColumn(i);
  }
  allRange.setFontFamily("Arial").setFontSize(10);

  writeLog("Применено форматирование к листу 'Диалоги'");
}

/**
 * Возвращает или создаёт лист "Логи скрипта".
 */
function getLogSheet() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var logSheet = ss.getSheetByName("Логи скрипта");
  if (!logSheet) {
    logSheet = ss.insertSheet("Логи скрипта");
    logSheet.getRange("A1:D1").setValues([["Время", "Уровень", "Сообщение", "Дополнительно"]]);
    logSheet.getRange("A1:D1").setBackground("#4285F4").setFontColor("white").setFontWeight("bold");
    logSheet.setFrozenRows(1);

    logSheet.setColumnWidth(1, 180);
    logSheet.setColumnWidth(2, 90);
    logSheet.setColumnWidth(3, 400);
    logSheet.setColumnWidth(4, 200);

    Logger.log("Создан лист 'Логи скрипта'");
  }
  return logSheet;
}

/**
 * Записывает сообщение в лист логов.
 */
function writeLog(message, level, extra) {
  if (!level) level = "INFO";
  Logger.log("[" + level + "] " + message);

  try {
    var logSheet = getLogSheet();
    var now = new Date();
    var timestamp = Utilities.formatDate(
      now, 
      SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone(), 
      "dd.MM.yyyy HH:mm:ss"
    );

    logSheet.insertRowAfter(1);
    var logRow = [timestamp, level, message, extra || ""];
    logSheet.getRange(2, 1, 1, 4).setValues([logRow]);

    var levelCell = logSheet.getRange(2, 2);
    switch(level.toUpperCase()) {
      case "ERROR":
        levelCell.setBackground("#f4c7c3");
        break;
      case "WARNING":
        levelCell.setBackground("#fce8b2");
        break;
      case "DEBUG":
        levelCell.setBackground("#d9d2e9");
        break;
      default:
        levelCell.setBackground("#d9ead3");
    }

    var lastRow = logSheet.getLastRow();
    if (lastRow > 1000) {
      logSheet.deleteRows(1001, lastRow - 1000);
    }
  } catch (e) {
    Logger.log("Ошибка при записи в лог: " + e);
  }
}

/**
 * Очищает лист "Логи скрипта", кроме шапки.
 */
function clearLogs() {
  try {
    var logSheet = getLogSheet();
    var lastRow = logSheet.getLastRow();
    if (lastRow > 1) {
      logSheet.deleteRows(2, lastRow - 1);
    }
    writeLog("Логи успешно очищены");
    SpreadsheetApp.getUi().alert("Логи", "Логи успешно очищены", SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    Logger.log("Ошибка при очистке логов: " + e);
    SpreadsheetApp.getUi().alert("Ошибка", "Не удалось очистить логи: " + e, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Инициализирует поля API (B1=botId, C1=token).
 */
function initializeApiFields() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) {
    dialogSheet = getDialogSheet();
  }

  var b1Value = dialogSheet.getRange("B1").getValue();
  var c1Value = dialogSheet.getRange("C1").getValue();
  var e1Value = dialogSheet.getRange("E1").getValue();
  if (!b1Value || b1Value === "ID бота") {
    dialogSheet.getRange("B1").setValue("ID бота")
      .setFontWeight("bold").setBackground("#e6f2ff");
  }
  if (!c1Value || c1Value === "API токен") {
    dialogSheet.getRange("C1").setValue("API токен")
      .setFontWeight("bold").setBackground("#e6f2ff");
  }
  if (!e1Value) {
    dialogSheet.getRange("E1").setValue("API обработчик: Остановлен")
      .setFontWeight("bold").setBackground("#ffe6e6");
  }
  formatDialogSheet();
  writeLog("Инициализированы поля для API", "INFO");
}

/**
 * Запускает API-обработчик.
 */
function startApiProcessing() {
  var ui = SpreadsheetApp.getUi();
  if (isApiRunning()) {
    ui.alert('API уже запущен', 'API-обработчик уже активен.', ui.ButtonSet.OK);
    writeLog("Попытка повторного запуска API, который уже активен", "WARNING");
    return;
  }

  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) {
    ui.alert('Ошибка', 'Лист "Диалоги" не найден!', ui.ButtonSet.OK);
    writeLog("Не удалось запустить API: лист 'Диалоги' не найден", "ERROR");
    return;
  }

  var botId = getBotId();
  var apiToken = getApiToken();
  if (!botId || !apiToken) {
    ui.alert('Ошибка', 'Укажите ID бота (B1) и токен (C1)!', ui.ButtonSet.OK);
    writeLog("Не удалось запустить API: нет botId или токена", "ERROR");
    return;
  }

  PropertiesService.getScriptProperties().setProperty('API_RUNNING', 'true');

  updateApiStatusDisplay();
  createApiTrigger();

  // Сразу пробуем обработать
  processApiMessagesSequential(true);

  ui.alert('API запущен', 'Обработчик активирован, последовательный режим.', ui.ButtonSet.OK);
  writeLog("API-обработчик успешно запущен (последовательный режим)", "INFO");
}

/**
 * Останавливает API-обработчик.
 */
function stopApiProcessing() {
  var ui = SpreadsheetApp.getUi();
  if (!isApiRunning()) {
    ui.alert('API не запущен', 'Нечего останавливать.', ui.ButtonSet.OK);
    writeLog("Попытка остановки неактивного API", "WARNING");
    return;
  }

  PropertiesService.getScriptProperties().setProperty('API_RUNNING', 'false');
  
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    var fn = triggers[i].getHandlerFunction();
    if (fn === 'processApiMessages' || fn === 'processApiMessagesSequential' || fn === 'continueApiProcessingSequential') {
      ScriptApp.deleteTrigger(triggers[i]);
      writeLog("Удалён триггер " + fn, "INFO");
    }
  }

  updateApiStatusDisplay();
  ui.alert('API остановлен', 'Обработчик остановлен.', ui.ButtonSet.OK);
  writeLog("API-обработчик остановлен", "INFO");
}

/**
 * Создаёт триггер для processApiMessagesSequential каждые 15 минут.
 */
function createApiTrigger() {
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === 'processApiMessagesSequential') {
      ScriptApp.deleteTrigger(triggers[i]);
    }
  }
  ScriptApp.newTrigger("processApiMessagesSequential")
    .timeBased()
    .everyMinutes(15)
    .create();
  writeLog("Создан триггер для processApiMessagesSequential каждые 15 минут");
}

/**
 * Проверяет, запущен ли API.
 */
function isApiRunning() {
  var apiRunning = PropertiesService.getScriptProperties().getProperty('API_RUNNING');
  return apiRunning === 'true';
}

/**
 * Обновляет отображение статуса API в ячейке E1.
 */
function updateApiStatusDisplay() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) return;

  var running = isApiRunning();
  var statusCell = dialogSheet.getRange("E1");
  if (running) {
    statusCell.setValue("API обработчик: Запущен (последовательный)")
      .setFontWeight("bold")
      .setBackground("#e6ffe6");
  } else {
    statusCell.setValue("API обработчик: Остановлен")
      .setFontWeight("bold")
      .setBackground("#ffe6e6");
  }
  writeLog("Статус API обновлён: " + (running ? "Запущен (последовательный)" : "Остановлен"), "INFO");
}

/**
 * Получает значение ID бота (Диалоги!B1).
 */
function getBotId() {
  var dialogSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Диалоги");
  if (!dialogSheet) return "";
  return dialogSheet.getRange("B1").getValue().toString().trim();
}

/**
 * Получает значение API токена (Диалоги!C1).
 */
function getApiToken() {
  var dialogSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Диалоги");
  if (!dialogSheet) return "";
  return dialogSheet.getRange("C1").getValue().toString().trim();
}

/**
 * Отправляет сообщение через API ChatForYou и возвращает ответ.
 */
function sendMessageAndGetResponse(token, botId, chatId, messageId, message) {
  var url = "https://api.chatforyou.ru/api/v1.0/ask/" + token;
  var payload = {
    bot_id: Number(botId),
    chat_id: chatId,
    message_id: messageId,
    message: message
  };

  var options = {
    method: "post",
    contentType: "application/json",
    headers: {
      Authorization: "Bearer " + token
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(url, options);
    var code = response.getResponseCode();
    var body = response.getContentText();
    if (code === 200) {
      var json = JSON.parse(body);
      var answer = json.done || json.response || null;
      return answer;
    } else {
      writeLog("API вернул код: " + code + " - " + body, "ERROR");
      return null;
    }
  } catch (e) {
    writeLog("Ошибка при fetch: " + e.message, "ERROR");
    return null;
  }
}

/**
 * Извлекает оригинальный диалог из текста с маркером [Собран]
 * @param {string} text - исходный текст с маркером
 * @return {string} - извлеченный диалог
 */
function extractOriginalDialog(text) {
  // Находим индекс маркера [Собран]
  var sobranIndex = text.indexOf("[Собран ");
  if (sobranIndex === -1) return text;
  
  // Находим конец строки с маркером
  var endOfMarkerLine = text.indexOf("\n\n", sobranIndex);
  if (endOfMarkerLine === -1) return text.substring(sobranIndex + 1);
  
  // Возвращаем только диалог после маркера
  return text.substring(endOfMarkerLine + 2);
}

/**
 * Обрабатывает ячейки последовательно с немедленным обновлением каждой.
 * Оптимизированная версия без прогресс-индикатора.
 * ДОБАВЛЕН: ChatID из колонки A добавляется в начало запроса к ИИ
 * @param {boolean} autoMode - автоматический режим работы
 * @param {number} startRow - начальная строка (если продолжаем обработку)
 * @param {number} startCol - начальный столбец (если продолжаем обработку)
 */
function processApiMessagesSequential(autoMode, startRow, startCol) {
  writeLog("=== Начало processApiMessagesSequential === (autoMode=" + autoMode +
           ", startRow=" + startRow + ", startCol=" + startCol + ")", "DEBUG");

  // Значения по умолчанию
  startRow = startRow || 2;
  startCol = startCol || 2;

  if (!isApiRunning()) {
    writeLog("API не активен! Обработка ячеек не выполняется.", "INFO");
    return;
  }

  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) {
    writeLog("Лист 'Диалоги' не найден. Остановка.", "ERROR");
    return;
  }

  var botId = dialogSheet.getRange("B1").getValue();
  var apiToken = dialogSheet.getRange("C1").getValue();
  if (!botId || !apiToken) {
    writeLog("Отсутствуют botId или API-токен в B1/C1", "ERROR");
    return;
  }

  // Регулярка "[Собран DD.MM.YYYY HH:MM:SS]"
  var sobranRegex = /\[Собран\s\d{2}\.\d{2}\.\d{4}\s\d{2}:\d{2}:\d{2}\]/;
  
  // Получаем размеры листа
  var lastRow = dialogSheet.getLastRow();
  var lastCol = dialogSheet.getLastColumn();
  
  writeLog("Размеры листа: " + lastRow + " строк, " + lastCol + " столбцов", "DEBUG");
  
  // Обработка одной ячейки
  var cellProcessed = false;
  var foundCellToProcess = false;
  
  // Цикл по строкам (1-based)
  outerLoop:
  for (var row = startRow; row <= lastRow; row++) {
    // Цикл по столбцам
    for (var col = (row === startRow ? startCol : 2); col <= lastCol; col++) {
      var cellValue = dialogSheet.getRange(row, col).getValue();
      if (!cellValue || cellValue.toString().trim() === "") {
        continue;
      }

      var cellText = cellValue.toString();
      if (!sobranRegex.test(cellText)) {
        continue;
      }
      if (cellText.indexOf("[Обработано ИИ]") !== -1) {
        continue;
      }

      // Нашли ячейку для отправки
      foundCellToProcess = true;
      writeLog("Найдена ячейка (" + row + "," + col + "), отправка...", "INFO");
      
      // НОВОЕ: Получаем ChatID из колонки A (столбец 1) той же строки
      var chatIDFromColumnA = dialogSheet.getRange(row, 1).getValue();
      var chatIDPrefix = "";
      if (chatIDFromColumnA && chatIDFromColumnA.toString().trim() !== "" && chatIDFromColumnA.toString().trim() !== "ChatID") {
        chatIDPrefix = "ChatID: " + chatIDFromColumnA.toString().trim() + "\n\n";
        writeLog("Добавлен префикс ChatID из колонки A: " + chatIDFromColumnA, "DEBUG");
      }
      
      var chatId = "cell_r" + row + "c" + col + "_" + new Date().getTime();
      var messageId = "msg_" + new Date().getTime();
      // НОВОЕ: Добавляем ChatID в начало запроса
      var messageText = chatIDPrefix + cellText;

      try {
        // Показываем, что ячейка обрабатывается
        dialogSheet.getRange(row, col).setBackground("#fff2cc"); // Желтый - в процессе
        
        // Отправляем запрос и получаем ответ
        var response = sendMessageAndGetResponse(apiToken, botId, chatId, messageId, messageText);
        if (response) {
          var now = new Date();
          var processedTimeStr = Utilities.formatDate(now, ss.getSpreadsheetTimeZone(), "dd.MM.yyyy HH:mm:ss");
          
          // Записываем только ответ и маркер обработки
          dialogSheet.getRange(row, col).setValue(
            "[Обработано ИИ " + processedTimeStr + "]\n" + response
          );
          dialogSheet.getRange(row, col).setBackground("#e6ffe6"); // Зеленый - успешно

          cellProcessed = true;
          writeLog("✅ Успешно обработана ячейка (" + row + "," + col + ")", "INFO");
        } else {
          writeLog("⚠️ Нет ответа от API, ячейка (" + row + "," + col + ")", "WARNING");
          dialogSheet.getRange(row, col).setBackground("#fff2cc"); // Оставляем желтый
        }
      } catch (err) {
        writeLog("❌ Ошибка в ячейке (" + row + "," + col + "): " + err, "ERROR");
        dialogSheet.getRange(row, col).setBackground("#f4cccc"); // Красный - ошибка
      }
      
      // Запоминаем следующую позицию
      PropertiesService.getScriptProperties().setProperty('API_CONTINUE_ROW', row.toString());
      PropertiesService.getScriptProperties().setProperty('API_CONTINUE_COL', (col + 1).toString());
      
      // Обработали одну ячейку, выходим из циклов
      break outerLoop;
    }
  }
  
  // Если нашли и обработали ячейку, продолжаем обработку напрямую
  if (foundCellToProcess) {
    if (isApiRunning()) {
      var nextRow = parseInt(PropertiesService.getScriptProperties().getProperty('API_CONTINUE_ROW') || '2');
      var nextCol = parseInt(PropertiesService.getScriptProperties().getProperty('API_CONTINUE_COL') || '2');
      
      writeLog("Продолжаем обработку следующей ячейки (" + nextRow + "," + nextCol + ")", "INFO");
      
      // Вместо создания нового триггера вызываем continueApiProcessingSequential напрямую
      // Это значительно ускорит выполнение
      continueApiProcessingSequential();
    }
  } else {
    writeLog("Не найдено ячеек для обработки. Завершаем.", "INFO");
    // Очищаем сохраненные позиции
    PropertiesService.getScriptProperties().deleteProperty('API_CONTINUE_ROW');
    PropertiesService.getScriptProperties().deleteProperty('API_CONTINUE_COL');
  }
  
  writeLog("=== Конец processApiMessagesSequential ===", "DEBUG");
}

/**
 * Продолжение последовательной обработки
 * Оптимизированная версия без использования триггеров для ускорения
 */
function continueApiProcessingSequential() {
  if (!isApiRunning()) {
    writeLog("API неактивен, не продолжаем", "INFO");
    return;
  }
  
  var props = PropertiesService.getScriptProperties();
  var row = parseInt(props.getProperty('API_CONTINUE_ROW') || '2');
  var col = parseInt(props.getProperty('API_CONTINUE_COL') || '2');

  // Без задержки продолжаем обработку следующей ячейки
  try {
    // Используем try-catch, чтобы предотвратить ошибки при превышении лимита времени выполнения
    processApiMessagesSequential(true, row, col);
  } catch (e) {
    writeLog("Ошибка при продолжении обработки: " + e.message, "ERROR");
    
    // Если произошла ошибка из-за превышения времени выполнения, 
    // создаем триггер для продолжения через 1 секунду
    var triggers = ScriptApp.getProjectTriggers();
    var hasExistingTrigger = false;
    
    for (var i = 0; i < triggers.length; i++) {
      if (triggers[i].getHandlerFunction() === 'continueApiProcessingSequential') {
        hasExistingTrigger = true;
        break;
      }
    }
    
    if (!hasExistingTrigger) {
      ScriptApp.newTrigger('continueApiProcessingSequential')
        .timeBased()
        .after(1000) // 1 секунда
        .create();
      writeLog("Создан триггер для возобновления после ошибки", "INFO");
    }
  }
}

/**
 * Функция-обёртка для ручного запуска обновления диалогов.
 */
function runUpdate() {
  updateDialogHistory();
  createTimeTriggerDialogs();
}

/**
 * Создаёт триггер для updateDialogHistory каждые 10 минут, если нет.
 */
function createTimeTriggerDialogs() {
  var triggers = ScriptApp.getProjectTriggers();
  var found = triggers.some(function(t) {
    return t.getHandlerFunction() === "updateDialogHistory";
  });
  if (!found) {
    ScriptApp.newTrigger("updateDialogHistory")
      .timeBased()
      .everyMinutes(10)
      .create();
    writeLog("Создан триггер для updateDialogHistory (каждые 10 мин)");
  } else {
    writeLog("Триггер updateDialogHistory уже существует", "INFO");
  }
}

/**
 * Функция выполняется при открытии таблицы. 
 * Автоматически настраивает обработку упоминаний ботов без необходимости ручной активации.
 */
function onOpen() {
  var ui = SpreadsheetApp.getUi();
  try {
    // Создаем основные меню
    ui.createMenu('Сборка диалогов')
      .addItem('📋 Инструкция', 'showInstructions')
      .addItem('📥 Собрать диалоги (runUpdate)', 'runUpdate')
      .addItem('🗑️ Очистить логи', 'clearLogs')
      .addToUi();

    ui.createMenu('API обработчик')
      .addItem('✅ Включить API обработчик', 'startApiProcessing')
      .addItem('❌ Выключить API обработчик', 'stopApiProcessing')
      .addToUi();

    ui.createMenu('Аналитика токенов')
      .addItem('📊 Обновить аналитику', 'runAnalyticsUpdate')
      .addItem('📈 Обновить диаграммы', 'runCreateCharts')
      .addToUi();
      
    // Меню для управления Telegram уведомлениями
    ui.createMenu('📱 Telegram Лиды')
      .addItem('✅ Включить автоотправку (каждую минуту)', 'createTelegramNotifierTrigger')
      .addItem('❌ Выключить автоотправку', 'removeTelegramNotifierTrigger')
      .addSeparator()
      .addItem('📊 Проверить статус', 'showTelegramNotifierStatus')
      .addItem('🖱️ Запустить сканирование вручную', 'manualScanForLeads')
      .addSeparator()
      .addItem('🧪 Тест подключения к Telegram', 'testTelegramConnection')
      .addToUi();
      
    // Временное меню для настройки Co-Pilot (можно удалить после установки)
    ui.createMenu('⚙️ Настройка Co-Pilot')
      .addItem('✅ Установить автоматическую обработку ботов', 'createInstalledTrigger')
      .addToUi();

    // Основная инициализация
    basicInitializeApiFields();
    simpleUpdateApiStatusDisplay();
    
    // Автоматическая инициализация Co-Pilot
    try {
      // Проверяем/создаем лист настроек
      var settingsSheet = ensureSettingsSheetExists();
      Logger.log("Лист настроек Co-Pilot проверен");
    } catch (e) {
      Logger.log("Ошибка при автоматической инициализации Co-Pilot: " + e);
    }
    
    Logger.log("Скрипт инициализирован");
  } catch (error) {
    Logger.log("Ошибка в onOpen: " + error);
  }
}

/**
 * Проверяет наличие или создает лист настроек Co-Pilot.
 * @return {Sheet} Лист с настройками
 */
function ensureSettingsSheetExists() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var settingsSheet = ss.getSheetByName("Настройки Co-Pilot");
  
  if (!settingsSheet) {
    // Создаем новый лист
    settingsSheet = ss.insertSheet("Настройки Co-Pilot");
    
    // Настраиваем заголовки
    settingsSheet.getRange("A1:B1").setValues([["ID бота", "API токен"]]);
    settingsSheet.getRange("A1:B1").setFontWeight("bold").setBackground("#4285F4").setFontColor("white");
    
    // Пример данных
    settingsSheet.getRange("A2:B2").setValues([["1234567", "ваш_токен_здесь"]]);
    
    // Форматирование
    settingsSheet.setColumnWidth(1, 150);
    settingsSheet.setColumnWidth(2, 300);
    
    // Добавляем инструкции
    settingsSheet.getRange("D1:F1").merge();
    settingsSheet.getRange("D1").setValue("ИНСТРУКЦИЯ ПО ИСПОЛЬЗОВАНИЮ УПОМИНАНИЙ БОТОВ");
    settingsSheet.getRange("D1").setFontWeight("bold").setBackground("#4285F4").setFontColor("white");
    
    var instructions = [
      ["1. Введите ID бота и токен API из ChatForYou в столбцы A и B"],
      ["2. В любой ячейке используйте формат: @botId Ваш запрос к боту"],
      ["3. Бот автоматически обработает все упоминания при изменении таблицы"],
      ["4. Можно использовать ссылки на ячейки в формате {A1} внутри запроса"],
      ["5. Используйте ## для разделения нескольких запросов в одной ячейке"]
    ];
    settingsSheet.getRange("D2:F6").setValues(instructions);
    
    Logger.log("Создан новый лист настроек Co-Pilot");
  }
  
  return settingsSheet;
}

/**
 * Проверяет, существует ли триггер для обработки упоминаний ботов.
 * @return {boolean} true, если триггер существует
 */
function checkBotMentionsTriggerStatus() {
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    var trigger = triggers[i];
    if (trigger.getHandlerFunction() === "processBotMentions" && 
        trigger.getEventType() === ScriptApp.EventType.ON_EDIT) {
      return true;
    }
  }
  return false;
}

/**
 * Упрощённая инициализация полей (ID бота, токен).
 */
function basicInitializeApiFields() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) {
    dialogSheet = getDialogSheet();
  }

  var b1Value = dialogSheet.getRange("B1").getValue();
  var c1Value = dialogSheet.getRange("C1").getValue();
  var e1Value = dialogSheet.getRange("E1").getValue();
  var f1Value = dialogSheet.getRange("F1").getValue();

  if (!b1Value || b1Value === "ID бота") {
    dialogSheet.getRange("B1").setValue("ID бота")
      .setFontWeight("bold").setBackground("#e6f2ff");
  }
  if (!c1Value || c1Value === "API токен") {
    dialogSheet.getRange("C1").setValue("API токен")
      .setFontWeight("bold").setBackground("#e6f2ff");
  }
  if (!e1Value) {
    dialogSheet.getRange("E1").setValue("API обработчик: Остановлен")
      .setFontWeight("bold").setBackground("#ffe6e6");
  }
  if (!f1Value) {
    dialogSheet.getRange("F1").setValue("Прогресс: 0 из 0 (0%)")
      .setFontWeight("bold").setBackground("#e6f2ff");
  }
  formatDialogSheet();
  Logger.log("Инициализированы поля API (basic)");
}

/**
 * Упрощённое обновление статуса API при открытии.
 */
function simpleUpdateApiStatusDisplay() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var dialogSheet = ss.getSheetByName("Диалоги");
  if (!dialogSheet) return;
  
  try {
    var running = isApiRunning();
    var statusCell = dialogSheet.getRange("E1");
    if (running) {
      statusCell.setValue("API обработчик: Запущен (последовательный)")
        .setFontWeight("bold")
        .setBackground("#e6ffe6");
      
    } else {
      statusCell.setValue("API обработчик: Остановлен")
        .setFontWeight("bold")
        .setBackground("#ffe6e6");
    }
  } catch (error) {
    Logger.log("Ошибка при обновлении статуса: " + error);
  }
}

/**
 * Анализ токенов
 */
function runAnalyticsUpdate() {
  var TokenAnalytics = {};
  
  // Проверяем, загружен ли модуль TokenAnalytics
  try {
    // Пытаемся вызвать функцию из модуля TokenAnalytics
    updateTokenAnalytics();
    writeLog("Запущено обновление аналитики токенов из модуля TokenAnalytics");
  } catch (e) {
    // Если модуль не загружен, показываем сообщение
    writeLog("Модуль TokenAnalytics не загружен: " + e.message, "WARNING");
    SpreadsheetApp.getUi().alert(
      "Модуль TokenAnalytics",
      "Модуль аналитики токенов не загружен или недоступен. " +
      "Пожалуйста, убедитесь, что модуль TokenAnalytics.gs добавлен в проект.",
      SpreadsheetApp.getUi().ButtonSet.OK
    );
  }
}

/**
 * Обновление диаграмм
 */
function runCreateCharts() {
  try {
    // Пытаемся вызвать функцию из модуля TokenAnalytics
    createAnalyticsCharts(false); // false означает ручной режим с диалогами
    writeLog("Запущено обновление диаграмм из модуля TokenAnalytics");
  } catch (e) {
    // Если модуль не загружен, показываем сообщение
    writeLog("Не удалось обновить диаграммы: " + e.message, "ERROR");
    SpreadsheetApp.getUi().alert(
      "Ошибка диаграмм",
      "Не удалось обновить диаграммы. " +
      "Пожалуйста, убедитесь, что модуль TokenAnalytics.gs добавлен в проект.\n\n" +
      "Ошибка: " + e.message,
      SpreadsheetApp.getUi().ButtonSet.OK
    );
  }
}

function showInstructions() {
  var ui = SpreadsheetApp.getUi();
  var msg = 
    "ИНСТРУКЦИЯ ПО ИСПОЛЬЗОВАНИЮ СКРИПТА:\n\n" +
    "1. Заполните поля в листе 'Диалоги':\n" +
    "   • B1 — ID бота в системе ChatForYou\n" +
    "   • C1 — API токен для доступа к ChatForYou\n\n" +
    "2. Для обработки диалогов:\n" +
    "   • Используйте 'Собрать диалоги' для объединения сообщений из Лист1\n" +
    "   • Диалоги группируются по ChatID и датам\n" +
    "   • ChatID теперь отображается в формате: 418838097 (@username)\n\n" +
    "3. Для обработки через API ChatForYou:\n" +
    "   • Включите API обработчик через меню\n" +
    "   • Система последовательно обрабатывает ячейки\n" +
    "   • ChatID из колонки A автоматически добавляется в начало каждого запроса к ИИ\n" +
    "   • Цвета ячеек: жёлтый - в процессе, зелёный - успешно, красный - ошибка\n\n" +
    "4. Отправка лидов в Telegram:\n" +
    "   • Меню '📱 Telegram Лиды' → 'Включить автоотправку'\n" +
    "   • Система каждую минуту сканирует лист 'Диалоги'\n" +
    "   • Находит ячейки с '🤖 АНАЛИЗ ОТ ИИ' и отправляет в Telegram\n" +
    "   • После отправки добавляется метка '✅ ЛИД ОТПРАВЛЕН'\n\n" +
    "5. Для работы аналитики токенов:\n" +
    "   • Убедитесь, что файл TokenAnalytics.gs добавлен в проект\n" +
    "   • Используйте меню 'Аналитика токенов' для обновления данных и диаграмм\n\n" +
    "6. Дополнительная функция - упоминания ботов:\n" +
    "   • В системе активирована функция упоминания ботов ChatForYou\n" +
    "   • Настройте ботов на автоматически созданном листе 'Настройки Co-Pilot'\n" +
    "   • В любой ячейке используйте формат @botId Ваш запрос\n" +
    "   • Обработка происходит автоматически при изменении таблицы";
  
  ui.alert("Инструкция по использованию", msg, ui.ButtonSet.OK);
}

/******************************************************
 * Конец main.gs
 ******************************************************/
